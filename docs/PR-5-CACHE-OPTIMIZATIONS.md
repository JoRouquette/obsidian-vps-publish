# PR #5: Cache Optimizations with Conditional Requests

## Purpose

Optimize HTTP caching strategy for content delivery while maintaining **content freshness**. This PR adds **ETag-based conditional caching** to `/content` routes (HTML pages, manifest) to reduce bandwidth and improve performance without serving stale content.

## Problem Statement

Before this PR:

- `/content/*.html` had **NO caching** (`etag: false, cacheControl: false, maxAge: 0`)
- `_manifest.json` had **NO caching**
- Every request downloaded full content, even if unchanged
- High bandwidth usage and slower page loads for returning visitors

## Solution

Implement **three-tier caching strategy**:

1. **Assets (`/assets`)**: Immutable, 365-day cache (unchanged)
2. **Content (`/content/*.html`)**: Conditional caching with ETags (5-minute cache, must-revalidate)
3. **Manifest (`_manifest.json`)**: Aggressive revalidation with ETags (60-second cache)

## When to Use

This caching strategy is appropriate for:

- **Static content** that changes infrequently but needs to stay fresh
- **Manifest files** that must be checked frequently for updates
- **Assets** that are versioned and never change (immutable)

## Key Concepts

### ETag (Entity Tag)

- **Hash of file content** generated by Express.js
- Sent in `ETag` response header
- Browser stores ETag and sends it back in `If-None-Match` request header
- Server compares ETags → **304 Not Modified** if match (no body sent)

### Conditional Requests

- **If-None-Match**: Client sends ETag from previous response
- **If-Modified-Since**: Client sends Last-Modified date from previous response
- Server returns **304 Not Modified** if content unchanged → **bandwidth saved**

### must-revalidate Directive

- Browser **MUST** check with server before serving cached content
- Prevents serving stale content when max-age expires
- Critical for dynamic content that changes occasionally

## Implementation Details

### Modified Files

#### `apps/node/src/infra/http/express/app.ts`

**Before**:

```typescript
// Content with no-cache (dynamic content, frequently updated)
app.use(
  '/content',
  disableCache,
  express.static(EnvConfig.contentRoot(), { etag: false, cacheControl: false, maxAge: 0 })
);
```

**After**:

```typescript
// Content with conditional caching (ETag validation)
// Enable ETags for content files but keep short max-age for freshness
app.use(
  '/content',
  express.static(EnvConfig.contentRoot(), {
    etag: true, // Enable ETag for conditional requests (If-None-Match)
    lastModified: true, // Enable Last-Modified for conditional requests (If-Modified-Since)
    maxAge: '5m', // Cache for 5 minutes, then revalidate
    cacheControl: true, // Send Cache-Control header
    setHeaders: (res, filePath) => {
      // Special handling for manifest: shorter cache + must-revalidate
      if (filePath.endsWith('_manifest.json')) {
        res.setHeader('Cache-Control', 'public, max-age=60, must-revalidate');
      }
      // HTML content: moderate cache with revalidation
      else if (filePath.endsWith('.html')) {
        res.setHeader('Cache-Control', 'public, max-age=300, must-revalidate');
      }
    },
  })
);
```

### Cache Strategy Breakdown

| Resource Type     | max-age    | Revalidation      | ETag | Use Case                                     |
| ----------------- | ---------- | ----------------- | ---- | -------------------------------------------- |
| `/assets/*`       | 365 days   | `immutable`       | Yes  | Images, PDFs (versioned, never change)       |
| `/content/*.html` | 5 minutes  | `must-revalidate` | Yes  | Published pages (change occasionally)        |
| `_manifest.json`  | 60 seconds | `must-revalidate` | Yes  | Content index (check frequently for updates) |

### Workflow Example: Content Request with ETag

```
1. First Request (User A):
   GET /content/my-page.html
   → 200 OK
   Headers:
     ETag: "abc123"
     Cache-Control: public, max-age=300, must-revalidate
     Last-Modified: Mon, 01 Jan 2025 12:00:00 GMT
   Body: <html>...</html> (full content)

2. Second Request (User A, within 5 minutes):
   GET /content/my-page.html
   → Browser serves from cache (no request sent)

3. Third Request (User A, after 5 minutes):
   GET /content/my-page.html
   If-None-Match: "abc123"
   → 304 Not Modified (no body sent, ~99% bandwidth saved)

4. Fourth Request (User B, content changed):
   GET /content/my-page.html
   If-None-Match: "abc123"
   → 200 OK
   Headers:
     ETag: "def456" (new hash)
   Body: <html>...</html> (updated content)
```

## Configuration

No new environment variables. Caching is **enabled by default** for all deployments.

To disable caching (e.g., for debugging):

```typescript
// Temporary override in app.ts
app.use('/content', disableCache, express.static(...));
```

## Testing

### Unit Tests (`cache-headers.test.ts`)

Created comprehensive test suite with **15 test cases**:

1. **Content Conditional Caching**:
   - ✅ Returns 200 with ETag and Cache-Control on first request
   - ✅ Returns 304 when ETag matches (If-None-Match)
   - ✅ Returns 304 when Last-Modified matches (If-Modified-Since)
   - ✅ Returns 200 with fresh content when ETag does not match

2. **Manifest Aggressive Revalidation**:
   - ✅ Returns shorter cache (60s) with must-revalidate
   - ✅ Returns 304 when manifest ETag matches

3. **Assets Immutable Caching**:
   - ✅ Returns 1-year cache with immutable directive
   - ✅ Returns 304 for assets when ETag matches

4. **Cache Strategy Comparison**:
   - ✅ Validates different max-age for manifest (60s) vs HTML (300s) vs assets (365d)
   - ✅ Enforces must-revalidate on content but not on immutable assets

### Manual Testing

```bash
# Test HTML page caching
curl -i http://localhost:3000/content/my-page.html
# → Check for ETag and Cache-Control headers

# Test conditional request (replace <etag> with actual value)
curl -i -H 'If-None-Match: "<etag>"' http://localhost:3000/content/my-page.html
# → Should return 304 Not Modified

# Test manifest caching
curl -i http://localhost:3000/content/_manifest.json
# → Should have max-age=60

# Test asset caching
curl -i http://localhost:3000/assets/image.png
# → Should have max-age=31536000 and immutable
```

### Performance Testing (Artillery)

Before/After comparison (see performance validation section below).

## Performance Impact

### Expected Improvements

1. **Bandwidth Reduction**:
   - ~99% bandwidth saved on **304 responses** (no body sent)
   - Typical HTML page: 50 KB → 0.5 KB (headers only)

2. **Response Time**:
   - 304 responses: ~5-10 ms (vs 20-50 ms for full content)
   - Browser cache hits: 0 ms (instant)

3. **Server Load**:
   - Reduced disk I/O for unchanged content
   - Faster ETag comparison vs full file read

### Validation

Run performance benchmarks:

```bash
# Before PR #5 (baseline)
npm run artillery:load-test

# After PR #5 (with caching)
npm run artillery:load-test
# Compare: response times, bandwidth usage, error rates
```

## Troubleshooting

### Issue: Content not updating after publish

**Symptom**: New content published but browser shows old version.

**Cause**: Browser cache not expired yet.

**Solution**:

1. Wait for max-age to expire (5 minutes for HTML)
2. Hard refresh: `Ctrl+Shift+R` (Chrome) or `Ctrl+F5` (Firefox)
3. Check manifest updated: `curl http://localhost:3000/content/_manifest.json`

### Issue: 304 responses but content actually changed

**Symptom**: Server returns 304 but content is different.

**Cause**: ETag not updated after file modification.

**Solution**:

1. Check file timestamp: `ls -l content/my-page.html`
2. Verify ETag changes after file update
3. Restart server if necessary (Express caches ETags)

### Issue: Assets not caching aggressively

**Symptom**: Assets requested on every page load.

**Cause**: Cache headers not applied or browser cache disabled.

**Solution**:

1. Verify Cache-Control: `curl -i http://localhost:3000/assets/image.png`
2. Check browser DevTools → Network → Disable cache is OFF
3. Verify `immutable` directive present

## Backward Compatibility

✅ **Fully backward compatible**:

- No API changes
- No breaking changes for clients
- ETags handled transparently by browsers
- Old clients without ETag support still work (receive full content)

## References

- **Source Code**:
  - [apps/node/src/infra/http/express/app.ts](../apps/node/src/infra/http/express/app.ts) - Cache configuration
  - [apps/node/src/\_tests/cache-headers.test.ts](../apps/node/src/_tests/cache-headers.test.ts) - Test suite

- **Related PRs**:
  - PR #2: Backend SEO API (sitemap ETag caching baseline)
  - PR #6: E2E Tests (validate caching in real browsers)

- **Standards**:
  - [RFC 7232: HTTP Conditional Requests](https://datatracker.ietf.org/doc/html/rfc7232)
  - [MDN: HTTP Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)
  - [Express.js static options](https://expressjs.com/en/4x/api.html#express.static)

## Next Steps

1. ✅ PR #5 complete: Cache optimizations implemented
2. ⏳ PR #6: E2E tests to validate caching in browsers
3. ⏳ PR #6: Final documentation and README update
